import uuid

import nibabel as nb
from nilearn import plotting, image as nlimage
from nipype.interfaces import ants, fsl
from nipype.interfaces.base import File, traits

from niworkflows.common import report

class RegistrationInputSpecRPT(ants.registration.RegistrationInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class RegistrationOutputSpecRPT(ants.registration.RegistrationOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class RegistrationRPT(report.ReportCapableInterface, ants.Registration):
    input_spec = RegistrationInputSpecRPT
    output_spec = RegistrationOutputSpecRPT

    def _generate_report(self):
        #  self.input_spec.fixed_image
        #  self.output_spec.warped_image
        with open(output_spec.html_report, 'w') as html_file:
            pass

class FASTInputSpecRPT(fsl.preprocess.FASTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FASTOutputSpecRPT(fsl.preprocess.FASTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FASTRPT(report.ReportCapableInterface, fsl.FAST):
    input_spec = FASTInputSpecRPT
    output_spec = FASTOutputSpecRPT

    def _generate_report(self):
        raise NotImplementedError


class BETInputSpecRPT(fsl.preprocess.BETInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class BETOutputSpecRPT(fsl.preprocess.BETOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class BETRPT(report.ReportCapableInterface, fsl.BET):
    input_spec = BETInputSpecRPT
    output_spec = BETOutputSpecRPT

    N_SLICES = 3 # number of slices to display per dimension

    def _generate_report(self):
        ''' generates a report showing three orthogonal slices of an arbitrary
        volume of in_file, with the resulting binary brain mask overlaid '''

        def _xyz_svgs(plot_func, cut_coord_basis, cut_coords_num, plot_params):
            ''' plot_func: function that returns an image like nilearn's plotting functions
                cut_coord_basis: nii image for which to calculate cut coords
                plot_params: dict of common parameters to plot_func
            returns a string of html containing svgs'''
            svgs = []
            for display_mode in 'x', 'y', 'z':
                plot_params['cut_coords'] = plotting.find_cut_slices(nb.load(cut_coord_basis),
                                                                     direction=display_mode,
                                                                     n_cuts=cut_coords_num)
                plot_params['display_mode'] = display_mode
                image = plot_func(**plot_params)
                svgs.append(report.as_svg(image))
                image.close()
            return '<br />'.join(svgs)

        def _plot_overlay_over_anat(**plot_params):
            ''' plot_params: dict of params for plot_func '''
            image = plotting.plot_anat(**plot_params)
            image.add_contours(self.aggregate_outputs().mask_file, filled=False, colors='r',
                               levels=[0.5], alpha=1)
            return image

        def _3d_in_file():
            ''' if self.inputs.in_file is 3d, return it.
            if 4d, pick an arbitrary volume and return that '''
            in_file = nlimage.concat_imgs(self.inputs.in_file) # result is always "4d"
            return nlimage.index_img(in_file, 0)

        background_params = {'anat_img': _3d_in_file(),
                             'cmap': 'gray'}
        base_svgs = _xyz_svgs(plotting.plot_anat, self.aggregate_outputs().mask_file,
                              self.N_SLICES, background_params)
        overlay_svgs = _xyz_svgs(_plot_overlay_over_anat,
                                 self.aggregate_outputs().mask_file,
                                 self.N_SLICES, background_params)

        report.save_html(template='overlay_3d_report.tpl',
                         report_file_name=self.html_report,
                         unique_string='bet' + str(uuid.uuid4()),
                         base_image=base_svgs,
                         overlay_image=overlay_svgs,
                         inputs=self.inputs,
                         outputs=self.aggregate_outputs(),
                         title='BET: Outline (calculated from brain mask) over the input '
                         '(anatomical)')

    def _generate_error_report(self):
        pass

class FLIRTInputSpecRPT(fsl.preprocess.FLIRTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FLIRTOutputSpecRPT(fsl.preprocess.FLIRTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FLIRTRPT(report.ReportCapableInterface, fsl.FLIRT):
    input_spec = FLIRTInputSpecRPT
    output_spec = FLIRTOutputSpecRPT

    def _generate_report(self):
        ref = self.inputs.reference
        ref_image_name = '{}.svg'.format(ref)
        out = self.inputs.out_file
        out_image_name = '{}.svg'.format(out)

        plotting.plot_img(ref, output_file=ref_image_name)
        plotting.plot_img(out, output_file=out_image_name)

        with open(ref_image_name, 'r') as file_obj:
            ref_image = file_obj.readlines()
            ref_image = ''.join(ref_image[4:])

        with open(out_image_name, 'r') as file_obj:
            out_image = file_obj.readlines()
            out_image = ''.join(out_image[4:])

        report.save_html(
            template='overlay_3d_report.tpl',
            report_file_name=self.html_report,
            unique_string='flirt' + str(uuid.uuid4()),
            base_image=ref_image,
            overlay_image=out_image,
            inputs=self.inputs,
            outputs=self.aggregate_outputs(),
            title="FLIRT: Overlay of registered image on top of reference file"
        )

class ApplyXFMInputSpecRPT(fsl.preprocess.ApplyXFMInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class ApplyXFMRPT(FLIRTRPT):
    ''' ApplyXFM is a wrapper around FLIRT. ApplyXFMRPT is a wrapper around FLIRTRPT.'''
    input_spec = ApplyXFMInputSpecRPT
