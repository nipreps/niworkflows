import uuid

from nilearn import plotting, image as nlimage
from nipype.interfaces import ants, fsl
from nipype.interfaces.base import File, traits

from niworkflows.common import report

class RegistrationInputSpecRPT(ants.registration.RegistrationInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class RegistrationOutputSpecRPT(ants.registration.RegistrationOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class RegistrationRPT(report.ReportCapableInterface, ants.Registration):
    input_spec = RegistrationInputSpecRPT
    output_spec = RegistrationOutputSpecRPT

    def _generate_report(self):
        #  self.input_spec.fixed_image
        #  self.output_spec.warped_image
        with open(output_spec.html_report, 'w') as html_file:
            pass

class FASTInputSpecRPT(fsl.preprocess.FASTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FASTOutputSpecRPT(fsl.preprocess.FASTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FASTRPT(report.ReportCapableInterface, fsl.FAST):
    input_spec = FASTInputSpecRPT
    output_spec = FASTOutputSpecRPT

    def _generate_report(self):
        raise NotImplementedError


class BETInputSpecRPT(fsl.preprocess.BETInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class BETOutputSpecRPT(fsl.preprocess.BETOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class BETRPT(report.ReportCapableInterface, fsl.BET):
    input_spec = BETInputSpecRPT
    output_spec = BETOutputSpecRPT

    def _overlay_file_name(self):
        ''' returns an overlay, in this order of preference: mask_file, outline_file,
        out_file, and the name of the output'''
        outputs = self.aggregate_outputs().get()

        for output_name in ['mask_file', 'outline_file', 'out_file']:
            if output_name:
                return outputs[output_name], output_name
        return None, None

    def _pick_output_file(self):
        for _, file_name in self.aggregate_outputs().get().items():
            if file_name and file_name.find('.nii') != -1: # rough check for nifti format
                return file_name
        raise Warning('Could not find outputs for BET; cannot generate report. Inputs are {} and'
                      ' outputs are {}.'.format(self.inputs, self.aggregate_outputs()))

    def _generate_report(self):
        ''' generates a report showing three orthogonal slices of an arbitrary
        volume of in_file, with the resulting binary brain mask overlaid '''

        def _xyz_svgs(plot_func, plot_params):
            ''' plot_func: function that returns an image like nilearn's plotting functions
                plot_params: dict of common parameters to plot_func
            returns a string of html containing svgs'''
            svgs = []
            for display_mode in 'x', 'y', 'z':
                plot_params['display_mode'] = display_mode
                image = plot_func(**plot_params)
                svgs.append(report.as_svg(image))
                image.close()
            return '<br />'.join(svgs)

        def _plot_overlay_over_anat(**plot_params):
            ''' plot_params: dict of params for plot_func '''
            image = plotting.plot_anat(**plot_params)
            image.add_contours(self._overlay_file_name()[0], filled=True, colors='b', levels=[0.5],
                               alpha=1)
            return image

        def _3d_in_file():
            ''' if self.inputs.in_file is 3d, return it.
            if 4d, pick an arbitrary volume and return that '''
            in_file = nlimage.concat_imgs(self.inputs.in_file) # result is always "4d"
            return nlimage.index_img(in_file, 0)

        try:
            # most of the time just do simple semi-transparent overlay of brain mask over input
            plot_params = {'roi_img': self.aggregate_outputs().mask_file,
                           'bg_img': _3d_in_file(),
                           'alpha': 0.6,
                           'cut_coords': 3}
            svgs = _xyz_svgs(plotting.plot_roi, plot_params)
            report.save_html(template='overlay_3d_report.tpl',
                             report_file_name=self.html_report,
                             unique_string='bet' + str(uuid.uuid4()),
                             base_image=svgs,
                             title="BET: brain mask over anatomical input",
                             inputs=self.inputs,
                             outputs=self.aggregate_outputs())
        except TypeError: # in case of weird outputs
            overlay_file_name, overlay_label = self._overlay_file_name()
            if overlay_file_name:
                background_params = {'anat_img': _3d_in_file(),
                                     'cut_coords': 3,
                                     'cmap': 'gray'}
                base_svgs = _xyz_svgs(plotting.plot_anat, background_params)
                overlay_svgs = _xyz_svgs(_plot_overlay_over_anat, background_params)

                report.save_html(template='overlay_3d_report.tpl',
                                 report_file_name=self.html_report,
                                 unique_string='bet' + str(uuid.uuid4()),
                                 base_image=base_svgs,
                                 overlay_image=overlay_svgs,
                                 inputs=self.inputs,
                                 outputs=self.aggregate_outputs(),
                                 title="BET: " + overlay_label + " over the input (anatomical)")

            else: # just print an output (no overlay)
                file_name = self._pick_output_file()
                image = plotting.plot_img(file_name)

                report.save_html(template='overlay_3d_report.tpl',
                                 report_file_name=self.html_report,
                                 unique_string='bet' + str(uuid.uuid4()),
                                 base_image=report.as_svg(image),
                                 title="BET: " + file_name,
                                 inputs=self.inputs,
                                 outputs=self.aggregate_outputs())
                image.close()

    def _generate_error_report(self):
        pass

class FLIRTInputSpecRPT(fsl.preprocess.FLIRTInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class FLIRTOutputSpecRPT(fsl.preprocess.FLIRTOutputSpec):
    html_report = File(desc="Filename of report generated by node")

class FLIRTRPT(report.ReportCapableInterface, fsl.FLIRT):
    input_spec = FLIRTInputSpecRPT
    output_spec = FLIRTOutputSpecRPT

    def _generate_report(self):
        ref = self.inputs.reference
        ref_image_name = '{}.svg'.format(ref)
        out = self.inputs.out_file
        out_image_name = '{}.svg'.format(out)

        plotting.plot_img(ref, output_file=ref_image_name)
        plotting.plot_img(out, output_file=out_image_name)

        with open(ref_image_name, 'r') as file_obj:
            ref_image = file_obj.readlines()
            ref_image = ''.join(ref_image[4:])

        with open(out_image_name, 'r') as file_obj:
            out_image = file_obj.readlines()
            out_image = ''.join(out_image[4:])

        report.save_html(
            template='overlay_3d_report.tpl',
            report_file_name=self.html_report,
            unique_string='flirt' + str(uuid.uuid4()),
            base_image=ref_image,
            overlay_image=out_image,
            inputs=self.inputs,
            outputs=self.aggregate_outputs(),
            title="FLIRT: Overlay of registered image on top of reference file"
        )

class ApplyXFMInputSpecRPT(fsl.preprocess.ApplyXfmInputSpec):
    generate_report = traits.Bool(
        desc="Set to true to enable report generation for node"
    )

class ApplyXFMRPT(FLIRTRPT):
    ''' ApplyXFM is a wrapper around FLIRT. ApplyXFMRPT is a wrapper around FLIRTRPT.'''
    input_spec = ApplyXFMInputSpecRPT
