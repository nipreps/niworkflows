# -*- coding: utf-8 -*-
# @Author: oesteban
# @Date:   2016-07-21 11:28:52
""" A robust ANTs T1-to-MNI registration workflow with fallback retry """

from __future__ import print_function, division, absolute_import, unicode_literals
from os import path as op
import shutil
import pkg_resources as pkgr
from uuid import uuid4
import numpy as np
from lxml import etree
from nilearn.plotting import plot_anat

from io import open
from nipype.interfaces.ants.registration import Registration, RegistrationOutputSpec
from nipype.interfaces.base import (traits, isdefined, BaseInterface, BaseInterfaceInputSpec,
                                    File, InputMultiPath)

from niworkflows.data import getters
from niworkflows.common import report
from niworkflows import __packagename__, NIWORKFLOWS_LOG

DEFAULT_MNI_CUTS = {
    'x': [-25, -20, -10, 0, 10, 20, 25],
    'y': [-25, -20, -10, 0, 10, 20, 25],
    'z': [-15, -10, -5, 0, 5, 10, 15]
}

SVGNS = "http://www.w3.org/2000/svg"

class RobustMNINormalizationInputSpec(BaseInterfaceInputSpec):
    moving_image = InputMultiPath(
        File(exists=True), mandatory=True, desc='image to apply transformation to')
    reference_image = InputMultiPath(
        File(exists=True), desc='override the reference image')
    moving_mask = File(exists=True, desc='moving image mask')
    reference_mask = File(exists=True, desc='reference image mask')
    num_threads = traits.Int(1, usedefault=True, nohash=True,
                             desc="Number of ITK threads to use")
    testing = traits.Bool(False, usedefault=True, desc='use testing settings')
    orientation = traits.Enum('RAS', 'LAS', mandatory=True, usedefault=True,
                              desc='modify template orientation (should match input image)')
    reference = traits.Enum('T1', 'T2', 'PD', mandatory=True, usedefault=True,
                            desc='set the reference modality for registration')
    moving = traits.Enum('T1', 'EPI', usedefault=True, mandatory=True,
                         desc='registration type')
    template = traits.Enum(
        'mni_icbm152_linear',
        'mni_icbm152_nlin_asym_09c',
        usedefault=True, desc='define the template to be used')
    settings = traits.List(File(exists=True), desc='pass on the list of settings files')
    template_resolution = traits.Enum(1, 2, mandatory=True, usedefault=True,
                                      desc='template resolution')
    generate_report = traits.Bool(
        False, usedefault=True, desc='enable report generation')
    html_report = File('viz-report.svg', usedefault=True, desc='visual report file')


class RobustMNINormalizationOutputSpec(RegistrationOutputSpec):
    html_report = File(desc="Filename of report generated by this node")


class RobustMNINormalization(report.ReportCapableInterface, BaseInterface):
    """
    An interface to robustly run T1-to-MNI spatial normalization.
    Several settings are sequentially tried until some work.
    """
    input_spec = RobustMNINormalizationInputSpec
    output_spec = RobustMNINormalizationOutputSpec

    def _list_outputs(self):
        return self._results

    def __init__(self, **inputs):
        self.norm = None
        self.retry = 0
        self._results = {}
        super(RobustMNINormalization, self).__init__(**inputs)

    def _get_settings(self):
        if isdefined(self.inputs.settings):
            NIWORKFLOWS_LOG.info('User-defined settings, overriding defaults')
            return self.inputs.settings

        filestart = '{}-mni_registration_'.format(self.inputs.moving.lower())
        if self.inputs.testing:
            filestart += 'testing_'

        filenames = [i for i in pkgr.resource_listdir('niworkflows', 'data')
                     if i.startswith(filestart) and i.endswith('.json')]
        return [pkgr.resource_filename('niworkflows.data', f)
                for f in sorted(filenames)]

    def _run_interface(self, runtime):
        settings_files = self._get_settings()

        if self.inputs.generate_report:
            self._results['html_report'] = op.abspath(self.inputs.html_report)

        for ants_settings in settings_files:
            interface_result = None

            self._config_ants(ants_settings)

            NIWORKFLOWS_LOG.info(
                'Retry #%d, commandline: \n%s', self.retry, self.norm.cmdline)
            try:
                interface_result = self.norm.run()
            except Exception as exc:
                NIWORKFLOWS_LOG.warn(
                        'Retry #%d failed: %s.', self.retry, exc)


            errfile = op.join(runtime.cwd, 'stderr.nipype')
            outfile = op.join(runtime.cwd, 'stdout.nipype')

            shutil.move(errfile, errfile + '.%03d' % self.retry)
            shutil.move(outfile, outfile + '.%03d' % self.retry)

            if interface_result is not None:
                self._results.update(interface_result.outputs.get())
                NIWORKFLOWS_LOG.info(
                    'Successful spatial normalization (retry #%d).', self.retry)

                # Roll back till implemented
                # return super(RobustMNINormalization, self)._run_interface(runtime)

                if self.inputs.generate_report:
                    try:
                        self._generate_report()
                    except Exception as reason:
                        NIWORKFLOWS_LOG.warn('Report was not generated, reason: %s', reason)
                return runtime

            self.retry += 1

        raise RuntimeError(
            'Robust spatial normalization failed after %d retries.' % (self.retry - 1))

    def _config_ants(self, ants_settings):
        NIWORKFLOWS_LOG.info('Loading settings from file %s.', ants_settings)
        self.norm = Registration(
            moving_image=self.inputs.moving_image,
            num_threads=self.inputs.num_threads,
            from_file=ants_settings,
            terminal_output='file'
        )
        if isdefined(self.inputs.moving_mask):
            self.norm.inputs.moving_image_mask = self.inputs.moving_mask

        if isdefined(self.inputs.reference_image):
            self.norm.inputs.fixed_image = self.inputs.reference_image
            if isdefined(self.inputs.reference_mask):
                self.norm.inputs.fixed_image_mask = self.inputs.reference_mask
            return

        get_template = getattr(getters, 'get_{}'.format(self.inputs.template))
        mni_template = get_template()

        if self.inputs.orientation == 'LAS':
            raise NotImplementedError

        resolution = self.inputs.template_resolution
        if self.inputs.testing:
            resolution = 2

        self.norm.inputs.fixed_image = op.join(
            mni_template, '%dmm_%s.nii.gz' % (resolution, self.inputs.reference))
        self.norm.inputs.fixed_image_mask = op.join(
            mni_template, '%dmm_brainmask.nii.gz' % resolution)


    def _generate_report(self):
        """ Generates the visual report """
        NIWORKFLOWS_LOG.info('Generating visual report')

        def _plot_xyz(anat_img, div_id, plot_params=None,
                      order=('z', 'x', 'y'), cuts=None,
                      estimate_brightness=False):
            """
            Plots the foreground and background views
            Default order is: axial, coronal, sagittal
            """
            plot_params = {} if plot_params is None else plot_params

            # Use default MNI cuts if none defined
            cuts = DEFAULT_MNI_CUTS.copy() if cuts is None else cuts

            NIWORKFLOWS_LOG.debug('Plotting %s for interface report.', anat_img)
            out_files = []


            if estimate_brightness:
                from nibabel import load as loadnii
                data = loadnii(anat_img).get_data().reshape(-1)
                vmin = np.percentile(data, 15)
                if plot_params.get('vmin', None) is None:
                    plot_params['vmin'] = vmin
                if plot_params.get('vmax', None) is None:
                    plot_params['vmax'] = np.percentile(data[data > vmin], 99.8)

            # Plot each cut axis
            for mode in list(order):
                out_file = '{}_{}.svg'.format(div_id, mode)
                plot_params['display_mode'] = mode
                plot_params['cut_coords'] = cuts[mode]
                plot_params['output_file'] = out_file

                # Generate nilearn figure
                plot_anat(anat_img, **plot_params)
                out_files.append(out_file)

                # Open generated svg file and fix id
                with open(out_file, 'rb') as f:
                    svg = f.read()

                # Find and replace the figure_1 id.
                xml_data = etree.fromstring(svg)
                find_text = etree.ETXPath("//{%s}g[@id='figure_1']" % (SVGNS))
                find_text(xml_data)[0].set('id', '%s-%s-%s' % (div_id, mode, uuid4()))

                with open(out_file, 'wb') as f:
                    f.write(etree.tostring(xml_data))
            return out_files

        def _compose_view(bg_svgs, fg_svgs, ref=0, out_file='report.svg'):
            import svgutils.transform as svgt
            import svgutils.compose as svgc

            # Read all svg files and get roots
            svgs = [svgt.fromfile(f) for f in bg_svgs + fg_svgs]
            roots = [f.getroot() for f in svgs]
            nsvgs = len(svgs) // 2
            # Query the size of each
            sizes = [(int(f.width[:-2]), int(f.height[:-2])) for f in svgs]

            # Calculate the scale to fit all widths
            scales = [1.0] * len(svgs)
            if not all([width[0] == sizes[0][0] for width in sizes[1:]]):
                ref_size = sizes[ref]
                for i, els in enumerate(sizes):
                    scales[i] = ref_size[0]/els[0]

            newsizes = [tuple(size)
                        for size in np.array(sizes) * np.array(scales)[..., np.newaxis]]

            # Compose the views panel: total size is the width of
            # any element (used the first here) and the sum of heights
            totalsize = [newsizes[0][0], np.sum(newsizes[:3], axis=0)[1]]
            fig = svgt.SVGFigure(totalsize[0], totalsize[1])

            yoffset = 0
            for i, r in enumerate(roots):
                size = newsizes[i]
                r.moveto(0, yoffset, scale=scales[i])
                yoffset += size[1]
                if i == (nsvgs - 1):
                    yoffset = 0

            # Group background and foreground panels in two groups
            newroots = [
                svgt.GroupElement(roots[:3], {'class': 'background-svg'}),
                svgt.GroupElement(roots[3:], {'class': 'foreground-svg'})
            ]
            fig.append(newroots)
            out_file = op.abspath(out_file)
            fig.save(out_file)

            # Add styles for the flicker animation
            with open(out_file, 'rb') as f:
                svg = f.read().split('\n')

            svg.insert(2, """\
  <style type="text/css">
  @keyframes flickerAnimation%s { 0%% {opacity: 1;} 100%% { opacity: 0; }}
  .foreground-svg { animation: 1s ease-in-out 0s alternate none infinite running flickerAnimation%s;}
  .foreground-svg:hover { animation-play-state: paused;}
  </style>""" % tuple([uuid4()] * 2))
            with open(out_file, 'wb') as f:
                f.write('\n'.join(svg))
            return out_file

        # Call composer
        _compose_view(
            _plot_xyz(self.norm.inputs.fixed_image[0], 'fixed-image',
                      estimate_brightness=True),
            _plot_xyz(self._results['warped_image'], 'moving-image',
                      estimate_brightness=True),
            out_file=self._results['html_report'])


    def _generate_error_report(self):
        pass
